(function () { var t; (t = angular.module("daterangepicker", [])).constant("dateRangePickerConfig", { separator: " - ", format: "YYYY-MM-DD" }), t.directive("dateRangePicker", ["$compile", "$timeout", "$parse", "dateRangePickerConfig", function (t, e, n, a) { return { require: "ngModel", restrict: "A", scope: { dateMin: "=min", dateMax: "=max", model: "=ngModel", opts: "=options" }, link: function (t, n, r, o) { var i, u, l, m, d, s, c, f, D, p; return u = $(n), i = t.opts, l = angular.extend({}, a, i), s = null, f = function (t) { return e(function () { var e; if (s) return e = moment(t), s.endDate < e && s.setEndDate(e), s.setStartDate(e) }) }, c = function (t) { return e(function () { var e; if (s) return e = moment(t), s.startDate > e && s.setStartDate(e), s.setEndDate(e) }) }, t.$watch("model.startDate", function (t) { return f(t) }), t.$watch("model.endDate", function (t) { return c(t) }), m = function (t) { var e; return e = function (t) { return moment.isMoment(t) ? t.format(l.locale.format) : moment(t).format(l.locale.format) }, l.singleDatePicker ? e(t.startDate) : [e(t.startDate), e(t.endDate)].join(l.separator) }, p = function (t, e) { var n; return t = moment(t), e = moment(e), n = t.isBefore(e) || t.isSame(e, "day"), o.$setValidity("min", n), n }, D = function (t, e) { var n; return t = moment(t), e = moment(e), n = t.isAfter(e) || t.isSame(e, "day"), o.$setValidity("max", n), n }, o.$formatters.push(function (t) { return t && t.startDate && t.endDate ? (f(t.startDate), c(t.endDate), t) : "" }), o.$parsers.push(function (e) { return angular.isObject(e) && e.hasOwnProperty("startDate") && e.hasOwnProperty("endDate") ? (t.dateMin && e.startDate ? p(t.dateMin, e.startDate) : o.$setValidity("min", !0), t.dateMax && e.endDate ? D(t.dateMax, e.endDate) : o.$setValidity("max", !0), e) : o.$modelValue }), o.$isEmpty = function (t) { return !t || null === t.startDate || null === t.endDate }, o.$render = function () { return o.$modelValue ? null === o.$modelValue.startDate ? u.val("") : u.val(m(o.$modelValue)) : u.val("") }, (d = function () { var t, n, a; u.daterangepicker(l, function (t, n, a) { return e(function () { return o.$setViewValue({ startDate: t, endDate: n }) }), o.$render() }), s = u.data("daterangepicker"), a = l.eventHandlers; for (n in a) t = a[n], u.on(n, t) })(), u.change(function () { if ("" === $.trim(u.val())) return e(function () { return o.$setViewValue({ startDate: null, endDate: null }) }) }), r.min && t.$watch("dateMin", function (t) { return t ? (o.$isEmpty(o.$modelValue) || p(t, o.$modelValue.startDate), l.minDate = moment(t)) : l.minDate = !1, d() }), r.max && t.$watch("dateMax", function (t) { return t ? (o.$isEmpty(o.$modelValue) || D(t, o.$modelValue.endDate), l.maxDate = moment(t)) : l.maxDate = !1, d() }), r.options && t.$watch("opts", function (t) { return l = angular.extend(l, t), d() }), t.$on("$destroy", function () { return null != s ? s.remove() : void 0 }) } } }]) }).call(this);
//# sourceMappingURL=angular-daterangepicker.min.map